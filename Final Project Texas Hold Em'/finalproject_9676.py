# -*- coding: utf-8 -*-
"""FinalProject_9676.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZGm024sxJBkXmsfm5YkrDqYpqfiieTIY
"""

# create ten functions to check the player card pattern (isRoyalFlush, isStraightFlush ...)

def isHighCard(player_hand):
  """
  Checks if the player's hand is a high card hand (no other better pattern).
  This function essentially returns True if none of the other hand ranking
  functions (pair, two pair, three of a kind, etc.) return True for the hand.

  Args:
    player_hand: A list of strings representing the cards in a player's hand.

  Returns:
    True if the hand is a high card hand, False otherwise.
  """
  from collections import Counter

  if len(player_hand) < 5:
    return False  # Cannot form any standard hand with less than 5 cards

  # Check for other patterns in descending order of rank
  if isRoyalFlush(player_hand):
    return False
  if isStraightFlush(player_hand):
    return False
  if isFourOfAKind(player_hand):
    return False
  if isFullHouse(player_hand):
    return False
  if isFlush(player_hand):
    return False
  if isStraight(player_hand):
    return False
  if isThreeOfAKind(player_hand):
    return False
  if isTwoPair(player_hand):
    return False
  if isPair(player_hand):
    return False

  # If none of the above conditions are met, it's a high card hand
  return True

def isFlush(player_hand):
  """
  Checks if all cards in a player's hand have the same suit.

  Args:
    player_hand: A list of strings representing the cards in a player's hand
                 (e.g., ['2♠', '5♠', 'K♠', 'A♠', '9♠']).

  Returns:
    True if all cards in the hand have the same suit, False otherwise.
  """
  if not player_hand:
    return False  # An empty hand cannot be a flush

  first_card = player_hand[0]
  first_suit = first_card[-1]  # Get the suit of the first card

  for i in range(1, len(player_hand)):
    current_card = player_hand[i]
    current_suit = current_card[-1]  # Get the suit of the current card
    if current_suit != first_suit:
      return False  # If any card has a different suit, it's not a flush

  return True  # If all cards have the same suit, it's a flush

def isStraight(player_hand):
  """
  Checks if the player's hand is a straight (five cards in rank sequence).
  Suits are ignored.

  Args:
    player_hand: A list of strings representing the cards in a player's hand.

  Returns:
    True if the hand is a straight, False otherwise.
  """
  if len(player_hand) < 5:
    return False

  rank_order = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']
  ranks = sorted([rank_order.index(card[:-1]) for card in player_hand])

  # Check for standard straight
  is_consecutive = True
  for i in range(len(ranks) - 1):
    if ranks[i+1] != ranks[i] + 1:
      is_consecutive = False
      break
  if is_consecutive:
    return True

  # Check for the special case of A-2-3-4-5 straight
  if set([rank_order[r] for r in ranks]) == {'A', '2', '3', '4', '5'}:
    return True

  return False

def isStraightFlush(player_hand):
  if isFlush(player_hand) and isStraight(player_hand):
    return True
  return False

def isRoyalFlush(player_hand):
  if isStraightFlush(player_hand):
    for card in player_hand:
      if card.startswith('A'):
        return True
  return False

def isThreeOfAKind(player_hand):
  """
  Checks if the player's hand has three cards of the same rank.

  Args:
    player_hand: A list of strings representing the cards in a player's hand.

  Returns:
    True if the hand has three of a kind, False otherwise.
  """
  ranks = [card[:-1] for card in player_hand]
  rank_counts = {}
  for rank in ranks:
    rank_counts[rank] = rank_counts.get(rank, 0) + 1
  for count in rank_counts.values():
    if count == 3:
      return True
  return False

def isFourOfAKind(player_hand):
  """
  Checks if the player's hand has four cards of the same rank.

  Args:
    player_hand: A list of strings representing the cards in a player's hand.

  Returns:
    True if the hand has four of a kind, False otherwise.
  """
  ranks = [card[:-1] for card in player_hand]
  rank_counts = {}
  for rank in ranks:
    rank_counts[rank] = rank_counts.get(rank, 0) + 1
  for count in rank_counts.values():
    if count == 4:
      return True
  return False

def isPair(player_hand):
  """
  Checks if the player's hand has exactly one pair (two cards of the same rank).

  Args:
    player_hand: A list of strings representing the cards in a player's hand.

  Returns:
    True if the hand has exactly one pair, False otherwise.
  """
  ranks = [card[:-1] for card in player_hand]
  rank_counts = {}
  pair_count = 0
  unique_ranks = set()
  for rank in ranks:
    rank_counts[rank] = rank_counts.get(rank, 0) + 1
  for rank, count in rank_counts.items():
    if count == 2:
      pair_count += 1
    unique_ranks.add(rank)
  return pair_count == 1

def isTwoPair(player_hand):
  """
  Checks if the player's hand has exactly two pairs (two sets of two cards of the same rank).

  Args:
    player_hand: A list of strings representing the cards in a player's hand.

  Returns:
    True if the hand has exactly two pairs, False otherwise.
  """
  ranks = [card[:-1] for card in player_hand]
  rank_counts = {}
  pair_count = 0
  for rank in ranks:
    rank_counts[rank] = rank_counts.get(rank, 0) + 1
  for count in rank_counts.values():
    if count == 2:
      pair_count += 1
  return pair_count == 2

def isFullHouse(player_hand):
  """
  Checks if the player's hand is a full house (three of a kind and a pair).

  Args:
    player_hand: A list of strings representing the cards in a player's hand.

  Returns:
    True if the hand is a full house, False otherwise.
  """
  ranks = [card[:-1] for card in player_hand]
  rank_counts = {}
  has_three = False
  has_pair = False
  for rank in ranks:
    rank_counts[rank] = rank_counts.get(rank, 0) + 1
  for count in rank_counts.values():
    if count == 3:
      has_three = True
    elif count == 2:
      has_pair = True
  return has_three and has_pair

def validate():
  player_flush_card = ['4♠', '4♠', 'K♠', '10♠', '7♠']
  print("isFlush: ", isFlush(player_flush_card))

  player_straight_card = ['5♣', '6♠', '7♠', '8♠', '9♠']
  print("isStraight: ", isStraight(player_straight_card))

  player_straight_flush_card = ['5♣', '6♣', '7♣', '8♣', '9♣']
  print("isStraightFlush: ", isStraightFlush(player_straight_flush_card))

  player_royal_flush_card = ['10♣', 'J♣', 'Q♣', 'K♣', 'A♣']
  print("isRoyalFlush: ", isRoyalFlush(player_royal_flush_card))

  player_full_house_card = ['5♣', '5♠', '5♦', '6♠', '6♦']
  print("isFullHouse: ", isFullHouse(player_full_house_card))

  player_four_of_a_kind_card = ['5♣', '5♠', '5♦', '5♥', '6♦']
  print("isFourOfAKind: ", isFourOfAKind(player_four_of_a_kind_card))

  player_three_of_a_kind_card = ['5♣', '5♠', '5♦', '6♠', '6♦']
  print("isThreeOfAKind: ", isThreeOfAKind(player_three_of_a_kind_card))

  player_two_pair_card = ['5♣', '5♠', '6♦', '6♠', '7♦']
  print("isTwoPair: ", isTwoPair(player_two_pair_card))

  player_pair_card = ['5♣', '5♠', '6♦', 'K♠', '7♦']
  print("isPair: ", isPair(player_pair_card))

  player_high_card = ['6♣', '4♠', 'K♠', '10♠', '7♠']
  print("isHighCard: ", isHighCard(player_high_card))


validate()

import random

def CreateDeckOfCards():
  suits = ['♠', '♦', '♥', '♣']
  face_values = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']

  deck_of_cards = [value + suit for suit in suits for value in face_values]

  return deck_of_cards

def shuffleDeck(deck_of_cards, times = 3):
  for _ in range(times):
    random.shuffle(deck_of_cards)

def deal(deck_of_cards, player_count, cards_per_player):
  """Deals cards to players from a shuffled deck.

  Args:
    deck_of_cards: A list representing the shuffled deck of cards.
    player_count: The number of players.
    cards_per_player: The number of cards to deal to each player.

  Returns:
    A list of lists, where each inner list represents a player's hand.
  """
  hands = []
  for _ in range(player_count):
    hand = []
    for _ in range(cards_per_player):
      if deck_of_cards: # check if deck is not empty.
        hand.append(deck_of_cards.pop(0))
      else:
        return hands, "Not enough cards in deck!"
    hands.append(hand)
  return hands, None

def PlayTexasHoldem():
  deck_of_cards = CreateDeckOfCards()
  shuffleDeck(deck_of_cards)
  players = deal(deck_of_cards, 4, 5)
  print(players)

  player_count = 2 # Example: 2 players
  cards_per_player = 5

  player_hands, error_message = deal(deck_of_cards, player_count, cards_per_player)

  if error_message:
    print(error_message)
  else:
    for i, hand in enumerate(player_hands):
      print(f"Player {i + 1} hand: {hand}")
  print(f"Remaining deck: {deck_of_cards}")
PlayTexasHoldem()